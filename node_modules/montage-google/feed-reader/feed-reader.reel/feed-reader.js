/* <copyright>
 This file contains proprietary software owned by Motorola Mobility, Inc.<br/>
 No rights, expressed or implied, whatsoever to this software are provided by Motorola Mobility, Inc. hereunder.<br/>
 (c) Copyright 2011 Motorola Mobility, Inc.  All Rights Reserved.
 </copyright> */
var Montage = require("montage").Montage,
    Component = require("montage/ui/component").Component;

exports.FeedReader = Montage.create(Component, {

    didCreate: {
        value: function() {
            var self = this;
            var apiInit = function() {
                console.log('google api initialized');

                google.load("feeds", "1", {
                    callback: function() {
                        console.log('google feeds api loaded');
                        self.needsDraw = true;
                        window.initGoogleAPI = null;
                    }
                });
            };

            // set up a global function
            window.initGoogleAPI = apiInit;
        }
    },

    _feedURL: {value: null},
    feedURL: {
        get: function() {
            return this._feedURL;
        },
        set: function(value) {
            this._feedURL = value;
            // execute the search and get the entries
            this._fetchFeed();
        }
    },

    // time in ms between slides
    interval: {value: 3, distinct: true},

    maxEntries: {value: 10, distinct: true},

    entries: {value: null},

    _feedDisplayMode: {value: null},
    feedDisplayMode: {
        get: function() {
            return this._feedDisplayMode;
        },
        set: function(value) {

            this.removeEntryAnimation();
            this._feedDisplayMode = value;

            this.addEntryAnimation();
        }
    },


    feedEntryTimer: {enumerable: false, value: null},


    activeFeedEntry: {value: null},
    _activeIndex: {value: null},
    activeIndex: {
        get: function() {
            return this._activeIndex || 0;
        },
        set: function(index) {
            if(this.entries) {
                var max = this.entries.length-1;
                if(index > max) {
                    index = 0;
                }
                if(index < 0) {
                    index = 0;
                }
                this._activeIndex = index;
                this.activeFeedEntry = this.entries[this._activeIndex];
            } else {
                this._activeIndex = 0;
            }
        }
    },

    _fetchFeed: {
        value: function() {

            var url = this.feedURL;
            var feed = new google.feeds.Feed(url);
            feed.setNumEntries(10);

            var self = this;
            self.entries = [];

            feed.load(function(result) {
                self.removeEntryAnimation();
                if(result.error) {
                    self.entries = [];
                } else {
                    //console.log('entries: ', result.feed.entries);
                    self.addEntryAnimation();
                    self.entries = result.feed.entries;
                    self.activeIndex = 0;
                    
                }


            });
        }
    },

    addEntryAnimation: {
        value: function() {
            var self = this;
            if("animation" == this.feedDisplayMode) {
                this.element.addEventListener('webkitAnimationStart', this);
                this.element.addEventListener('webkitAnimationIteration', this);
                this.element.addEventListener('webkitAnimationEnd', this);
            } else {
                // timer
                this.feedEntryTimer = setInterval(function() {
                    self.activeIndex = self.activeIndex + 1;
                }, (this.interval * 1000));
            }
        }
    },

    removeEntryAnimation: {
        value: function() {
            if("animation" == this.feedDisplayMode) {
                this.element.removeEventListener('webkitAnimationStart', this);
                this.element.removeEventListener('webkitAnimationIteration', this);
                this.element.removeEventListener('webkitAnimationEnd', this);

            } else {
                if(this.feedEntryTimer) {
                    window.clearInterval(this.feedEntryTimer);
                }
            }
        }
    },

    handleWebkitAnimationStart: {
        value: function() {
            console.log('animation start');
        }
    },

    handleWebkitAnimationIteration: {
        value: function() {
           console.log('animation iteration');
           this.activeIndex = this.activeIndex + 1;
       }
   },

   handleWebkitAnimationEnd: {
       value: function() {
           console.log('animation end');
       }
    },

    prepareForDraw: {
        value: function() {
        }
    },

    draw: {
        value: function() {

        }
    }

});
